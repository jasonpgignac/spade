# ==========================================================================
# Project:   Spade - CommonJS Runtime
# Copyright: Â©2010 Strobe Inc. All rights reserved.
# License:   Licened under MIT license (see LICENSE)
# ==========================================================================

module Spade
  BOOT_PATH = File.expand_path(File.join(File.dirname(__FILE__), '..'));
  BUILTIN_PACKAGES = File.join File.dirname(BOOT_PATH), 'packages'

  module Bundle
    class << self

      def update(rootdir, opts ={})

        verbose = opts[:verbose]
        spade_path = File.join(rootdir, SPADE_DIR)
        FileUtils.rm_r(spade_path) if File.exists? spade_path

        FileUtils.mkdir_p spade_path
        FileUtils.mkdir_p File.join(spade_path, 'packages')

        FileUtils.ln_s BOOT_PATH, File.join(spade_path, 'boot')

        installed = []


        #TODO: Clean up duplication here

        Dir.glob(File.join(BUILTIN_PACKAGES, '*')).each do |path|
          next unless File.exists? File.join(path, 'package.json')

          next if installed.include? path
          installed << path

          new_path = File.join(spade_path, 'packages', File.basename(path))
          FileUtils.ln_s path, new_path, :force => true
          puts "Installing built-in package #{File.basename(path)}" if verbose
        end

        # Do this to get the Gem.dir right
        env = Spade::Environment.new
        Dir.glob(File.join(env.spade_dir, 'gems', '*')).each do |path|
          package_def = File.join(path, 'package.json')
          next unless File.exists?(package_def)

          next if installed.include? path
          installed << path

          json = JSON.load File.read(package_def)
          package_name = json['name']
          new_path = File.join(spade_path, 'packages', package_name)
          FileUtils.ln_s path, new_path, :force => true
          puts "Installing system package #{File.basename(path)}" if verbose
        end


        Dir.glob(File.join(rootdir, 'packages', '*')).each do |path|
          next unless File.exists? File.join(path, 'package.json')

          next if installed.include? path
          installed << path

          package_name = File.basename(path)
          old_path = File.join('..','..','packages', package_name)
          new_path = File.join(spade_path, 'packages', File.basename(path))
          FileUtils.ln_s old_path, new_path, :force => true
          puts "Installing local package #{File.basename(path)}" if verbose
        end

        File.open(File.join(rootdir, 'spade-boot.js'), 'w+') do |fp|
          fp.write gen_spade_boot(rootdir, opts)
        end
        puts "Wrote spade-boot.js" if verbose


      end

      def gen_spade_boot(rootdir, opts={})
        verbose = opts[:verbose]
        spade_path = File.join(rootdir, SPADE_DIR, 'packages', '*')
        known_packages = Dir.glob(spade_path).map do |path|
          package_name = File.basename path
          info = JSON.load File.read(File.join(path, 'package.json'))
          info["sync"] = true
          info["root"] = "#{SPADE_DIR}/packages/#{package_name}"
          info["files"] = package_file_list(path)
          info
        end

        if File.exists? File.join(rootdir, 'package.json')
          info = JSON.load File.read(File.join(rootdir, 'package.json'))
        else
          info = { 
            "name" => File.basename(rootdir), 
            "directories" => { "lib" => "lib" } 
          }
        end

        info["root"] = '.'
        info["sync"] = true
        info["files"] = package_file_list('.')

        packages = resolve_dependencies(info, known_packages)

%[// GENERATED: #{Time.now.to_s}
// This file is automatically generated by spade.  To update run 
// 'spade update'. To use this file, reference it in your HTML file.  Base 
// sure that your base URL is to the top level directory containing all of 
// your files.

/*globals spade */
//@ begin boot
(function() {
  // load spade itself
  var script = document.createElement('script');
  script.src = "#{SPADE_DIR}/boot/spade.js";
  script.onload = function() {

    // Register remaining packages with spade
#{packages.map{|p| %[spade.register("#{p["name"]}", #{JSON.pretty_generate(p)});\n] } * "\n"}

    // find the main module to run
    var main = null;
    var scripts = document.scripts || document.getElementsByTagName("script"),
        len = scripts.length;
    for(var idx=0;!main && idx<len;idx++) {
      main = scripts[idx].getAttribute('data-require');
    }
    scripts = null; // avoid memory leaks in IE

    if (main) spade.ready(function() { spade.require(main); });
  };

  var head = document.head || document.body || document;
  head.appendChild(script);

  script = head = null; // avoid memory leaks in IE
})();
//@ end boot
]

      end

      private

        def package_file_list(path)
          get_all_files(path).map{|p| p.sub(path+File::SEPARATOR, '') } - %w(package.json spade-boot.js)
        end

        # Supports recursive, be careful
        def get_all_files(path)
          Dir.glob(File.join(path, '**', '*')).
            map{|p| File.symlink?(p) ? get_all_files(p) : p }.
            flatten.
            reject{|p| File.extname(p).empty? }
        end

        def resolve_dependencies(package, available)
          # TODO: Should available be a hash to speed lookup?
          if package["dependencies"]
            # TODO: Check version numbers
            dependencies = package["dependencies"].keys
            packages = available.select{|p| dependencies.include?(p["name"]) }.
                                 map{|p| resolve_dependencies(p, available) }.
                                 flatten
            (packages << package).uniq
          else
            [package]
          end
        end

    end

  end
end
